---
output:
    bookdown::pdf_document2: default
linkcolor: blue
bibliography: C:/Users/colej/Documents/Research projects/bib_ch.bib
#biblio-style: "apalike"
fontsize: 12pt
link-citations: yes
toc: false
csl: C:/Users/colej/Documents/Research projects/ji_manipulation_protest/american-journal-of-political-science.csl
indent: true
header-includes: 
  - \usepackage{booktabs}
  - \usepackage{setspace}
  - \usepackage{float}
  - \usepackage{caption}
  - \captionsetup[table]{labelformat=empty}
---

\doublespace

On August 9, 2020, Belarus held an election in which President Aleksander Lukashenko ran for a sixth term. The official results credited Lukashenko with over 80\% of the vote, a result which observers regarded as wildly inflated [@GolosPlatformPresents2020]. In response, hundreds of thousands of Belarusians took to the streets over the course of several months. Though the protests put significant strain on the regime, a harsh campaign of repression (and support from neighboring Russia) ultimately quelled the protests; Lukashenko was inaugurated into a new five-year term. 

The Belarusian case is typical in some ways, and an outlier in others. Like many previous elections in Belarus, and in authoritarian regimes around the world, the contest was heavily managed and the results inflated by fraud. However, the sustained, massive protest wave that occurred post-election is extremely unusual. However, the regime's ultimate victory over the protest movement\textemdash while costly and never guaranteed\textemdash is also the typical outcome of post-election protest.

These patterns highlight a puzzle generated by existing research on the relationship between election manipulation and popular protest. The topic has significant implications for authoritarian governance and democratization, and as such has been a very active subject of study. However, the various theoretical perspectives brought to bear on the topic have generated competing predictions. To briefly summarize: for some models, election fraud is a tool of weak incumbents. As a result, incumbents avoid fraud when it might be exposed and reveal their weakness to potential protesters\textemdash an auspicious prediction for democratization and ultimately the under-pinning of 'self-enforcing' democracy [@fearon2011]. For others, fraud is committed by weak and strong incumbents alike, making protest a risky gamble the opposition undertakes for other reasons. In these models, fraud may or may not be deterred based on other exogenous factors: a dubious, though not completely dismissive, prospect for democratization and self-enforcing democracy. Lastly, a third school of thought holds that election fraud is an indicator of genuine incumbent strength. This approach, which is expanded upon below, is a pessimistic account for democracy. If this model is correct, it is authoritarian politics rather than democracy that is self-enforcing\textemdash the ability to commit election fraud helps win elections, signal strength, deter challengers under most conditions, and put down protest movements if they do begin. This paper argues that the third model best fits the overall pattern of the data, and is supported by specific hypothesis tests.      

In this paper, I argue that\textemdash in keeping with the idea of 'informational autocracy' (ADD CITES HERE)\textemdash an election outcome produces a signal of the relative strength of the incumbent. As Magaloni (2008) and others have noted, incumbents typically work to produce a higher margin of victory in the election, in order to demonstrate their strength and induce cooperation from other actors in society. In some theories, this only works if the votes for the incumbent are largely 'genuine' (i.e. not fabricated), or produced using the incumbent's organizational resources (i.e. vote-buying and intimidation). (ADD CITES HERE, INCLUDING TO HARVEY AND M). These two kinds of votes correspond to two of the three 'pillars of stability' identified by Gerschewski (2013) (ADD CITE): legitimation and cooptation. Fraud is considered a form of cheap talk in these models, which opposition actors can discount if they become aware of it. 

However, these models overlook that engineering widespread fraud requires control over patronage resources and the criminal and judicial apparatus (ADD CITES to HARVEY). As a result, they overlook the fact that high levels of fraud are a sign of incumbent strength in cooptation and Gerschewski's third pillar: repression. Both of these tools can be useful for defusing or dismantling an emergent protest movement. As a result, effective fraudsters should also be effective protest-crushers. This helps explain the broad pattern, where most fraudulent elections go unprotested, and among those that do generate protest, the vast majority fail to dislodge the incumbent. Consequently, there is little penalty for severe manipulation in terms of protest risk, and little deterrent effect.

Testing this proposition in more depth is difficult.  requires looking beyond binary measures of protest, and toward measures of its scope. Research on the risk posed to governments by electoral protest often acknowledges---whether explicitly or implicitly---the importance of broad-based protest campaigns, rather than one-off events [@Bunce2006;@tucker2007;@DAnieri2006;@Carnaghan2016;@bunce2010]. This implicit assumption has largely been overlooked in theories and empirical studies of the relationship between election manipulation and protest, however. In most cases, the risk of protest has both been conceptualized and operationalized as a binary outcome: protests occur or they do not. This approach obscures the importance of the number and size of electoral protests in a ruling party's calculation of the risk involved in manipulation an election. 


Using cross-national data on 1110 elections from 1989 to 2012 where incumbents claimed victory, combining data from NELDA [@hyde_2012_marinov], V-Dem [@vdem11.1], and the Electoral Contention and Violence dataset [@Daxecker2019], this paper finds little support for the hypothesis that more fraudulent elections are associated with a higher risk that any post-election protest event occurs. Furthermore, it shows that more severe election fraud is not associated with more numerous or larger post-election protests. Instead, these protest dynamics appear driven more by structural and institutional factors, including in particular whether or not the incumbent chief executive is term limited. 

Since fraud is not associated with the overall number or size of of events in a protest wave, the risk to governments has likely been overemphasized. That is, even if protests do break out in response to large-scale fraud, the government has many tools it may deploy to curtail them. Once protests begin, the noisy signal of regime strength provided by the election is replaced by a very clear signal: the force of the regime's response to the emerging protest movement in contest with the mobilizational capacity of the opposition.  To the extent that larger protest waves are more damaging to the government than small ones, protest risk does not appear to be a substantial constraint on the severity of election fraud. Troublingly, these findings indicate that ruling parties should follow an 'all-in' strategy on election manipulation. More manipulation is not associated with a larger number of protests, but a large margin of victory is associated with a lower risk of protest initiation. These results help explain both the relative paucity of electoral protests, the rarity of their success in overturning incumbent regimes, and governments' attempts to claim implausibly high margins of victory. They also suggest that protest risk should be de-emphasized in research on the causes of election manipulation, in favor of alternative explanations which emphasize the role of front-line actors in delivering manipulation.

 
# Data and methods

```{r setup, include = FALSE}
library(tidyverse)
library(countrycode)
library(readxl)
library(vdemdata)
library(lme4)
library(interplot)
library(lubridate)
library(summarytools)
library(stargazer)
library(ggeffects)
library(glmmTMB)
library(modelsummary)
library(huxtable)
library(simPH)

nelda2.sub <- read.csv(here::here("Data", "nelda2_sub_2024-01-16.csv"))


nelda2.sub <- nelda2.sub %>% mutate(legit_no_proc = (v2exl_legitperf + v2exl_legitlead + v2exl_legitideol))
nelda2.sub <- nelda2.sub %>% mutate(legit_total = (v2exl_legitperf + v2exl_legitlead + v2exl_legitideol + v2exl_legitratio))



##Naming nelda variables

nelda2.sub <- nelda2.sub %>% rename(boycott = nelda14)
nelda2.sub <- nelda2.sub %>% mutate(boycott = ifelse(boycott == "yes", 1, ifelse(boycott == "no", 0,
                                                                                 NA)))

##Creating economic crisis variable

nelda2.sub <- nelda2.sub %>% mutate(econ.crisis = ifelse(is.na(e_miinflat) == T | is.na(gdpgro.1lag) == T, NA, ifelse(e_miinflat > 15 | gdpgro.1lag <= -0.012, 1, 0)))
nelda2.sub <- nelda2.sub %>% mutate(econ.crisis = as.factor(econ.crisis))

nelda2.sub <- nelda2.sub %>% mutate(gdp.crisis = ifelse(is.na(gdpgro.1lag) == T, NA, ifelse(gdpgro.1lag <= -0.012, 1, 0)))
nelda2.sub <- nelda2.sub %>% mutate(inflat.crisis = ifelse(is.na(e_miinflat) == T, NA, ifelse(e_miinflat > 15, 1, 0)))

nelda2.sub <- nelda2.sub %>% mutate(grievance.index = ifelse(is.na(e_migdppcln) == T, NA, e_migdppcln*v2xeg_eqdr))



## Removing cases where inc. loses
#nelda2.sub <- nelda2.sub %>% filter(inc.lose == 0)  #See how this affects things

##Intmon as a factor
nelda2.sub <- nelda2.sub %>% mutate(v2elintmon = as.factor(v2elintmon))


nelda2.sub <- nelda2.sub %>% mutate(electoral.dem = ifelse(v2x_regime == 2, 1, 0))

#Square of physint

nelda2.sub <- nelda2.sub %>% mutate(physintlag.sq = physinteg.1lag^2)

## Categorical variable for incumbent status

nelda2.sub <- nelda2.sub %>% mutate(incumb.status = as.factor(ifelse(inc.termlimit == "yes" & chosen.successor == 1, "Chosen successor",
                                                           ifelse(inc.termlimit == "yes" & chosen.successor == 0, "Contested exec. election", 
                                                                  ifelse(inc.termlimit == "no", "Executive eligible", "Legislative election"))))) 
nelda2.sub <- nelda2.sub %>% mutate(incumb.status = relevel(incumb.status, ref = "Legislative election"))


#Coding as factors

nelda2.sub <- nelda2.sub %>% mutate(presidential = factor(presidential))
#nelda2.sub <- nelda2.sub %>% mutate(inc.termlimit.num = factor(inc.termlimit.num))
nelda2.sub <- nelda2.sub %>% mutate(rentierstate = factor(rentierstate))
nelda2.sub <- nelda2.sub %>% mutate(taxstate = factor(taxstate))
nelda2.sub <- nelda2.sub %>% mutate(unscheduled_election = factor(unscheduled_election))
nelda2.sub <- nelda2.sub %>% mutate(inc.lose = factor(inc.lose))
nelda2.sub <- nelda2.sub %>% mutate(econ.crisis.nelda.1lag = factor(econ.crisis.nelda.1lag))


#Successful protest = new elections or new incumbent

nelda2.sub <- nelda2.sub %>% mutate(protest.success = ifelse(inc.replaced.prot == 1 | new.elections.held == 1, 1, 0))



# Replacing NA with 0 for term limits variable in known parliamentary countries in legislative elections

nelda2.sub <- nelda2.sub %>% mutate(inc.termlimit.num = ifelse(is.na(inc.termlimit.num) == T & v2ex_elechog == 0, 0, inc.termlimit.num))

## Replacing NA with 0 for protest size

nelda2.sub <- nelda2.sub %>% mutate(max_size = ifelse(is.na(max_size)==T & n.events.post == 0, 0, max_size))

## Fixing missing values of winner.share.upd for liberal democracies

nelda2.sub <- nelda2.sub %>% mutate(winner.share.upd = ifelse(is.na(winner.share.upd)==T & v2x_regime == 3, winner.margin, winner.share.upd))

## Set max_size zero for elections with no protest

nelda2.sub <- nelda2.sub %>% mutate(max_size = ifelse(n.events.post == 0, 0, max_size))

## Excluding liberal democracies

nelda2.sub <- nelda2.sub %>% filter(v2x_regime == 1) #Includes only authoritarian

#Protest cases only

protest.cases <- nelda2.sub %>% filter(any.ecav.protest == 1)


```




```{r, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}

p.hist.events <- ggplot(nelda2.sub, aes(x=n.events.post)) + geom_histogram(bins = 90) + xlab("Number of protest events") + theme_bw()

p.hist.size <- ggplot(nelda2.sub, aes(x=max_size)) + geom_histogram(bins=100) + xlab("Maximum protest size") + theme_bw()


p.hist.fraud <- ggplot(nelda2.sub, aes(x = v2elirreg.inv)) + geom_histogram(bins=100) + xlab("Election fraud") + theme_bw()


 ggplot(nelda2.sub, aes(y = v2elirreg.inv, x= jitter(n.events.post))) + geom_point(aes(color = factor(inc.fav.cancel.protests))) + xlab("n.events.post (jittered)") + theme_bw()
 
  ggplot(nelda2.sub, aes(y = v2elirreg.inv, x= max_size)) + geom_point(aes(color = factor(inc.fav.cancel.protests))) + xlab("max size") + theme_bw()
```


```{r elex-hist, fig.cap="Distributions of election fraud, post-election protest, and maximum protest size", fig.height=7, echo=FALSE, message=FALSE, warning = FALSE}
plot.combined.hist <- cowplot::plot_grid(p.hist.fraud, p.hist.events, p.hist.size, ncol=1)
plot.combined.hist
```


```{r, include=F}
incl.vars <- nelda2.sub %>% dplyr::select('Judicial independence' = jucon.1lag, 
                                            'Legislative constraints' = legcon.1lag, 
                                            'Alternative information' = altinf.1lag,
                                          'Liberal democracy index' = libdem.1lag,
                                            'GDP growth rate' = gdpgro.1lag, 
                                            'Civil society openness' = osorg.1lag, 
                                            #'Public sector corruption' = pubseccorrup.lag,
                                            'National party organization' = natlpartyorg.lag, 
                                             'Election fraud' = v2elirreg.inv, 
                                            'Presidential election' = presidential,
                                            'Incumbent term-limited' = inc.termlimit.num,
                                            'Physical integrity index' = physinteg.1lag,
                                            'Urbanization' = urban.pct, 
                                            'Rentier state' = rentierstate,
                                            'Tax state' =  taxstate,
                                            'Winning vote-share' = winner.share.upd, 
                                            'Number of pre-election protests' = n.events.pre,
                                            'Off-schedule election' = unscheduled_election,
                                          'Regional protest diffusion' = regional_success_lag)
#incl.vars <- incl.vars %>% mutate(v2elintmon = as.numeric(v2elintmon))


```

\singlespace


```{r summary-table, echo=FALSE, message=FALSE, warning=FALSE}
library(kableExtra)
datasummary_skim(incl.vars, output = "kableExtra", title = "Table 1: Summary statistics and variable distributions ")  %>%
    kable_styling(font_size = 9, full_width = FALSE)
```
\doublespace





## Explanatory variables



\newpage

\singlespace

```{r manipdv, echo=FALSE}
m1 <- lmer(v2elirreg.inv ~ jucon.1lag + legcon.1lag + gdpgro.1lag +  osorg.1lag  + natlpartyorg.lag   +  presidential +  urban.pct + rentierstate + taxstate + n.events.pre  +  unscheduled_election + state.owned.1lag + patronage.appts.1lag + antisys.1lag + v2elembaut + (1 | stateid), data = nelda2.sub) 

#summary(m1)

m1a <- lmer(v2elirreg.inv ~ jucon.1lag + legcon.1lag + gdpgro.1lag +  osorg.1lag  + natlpartyorg.lag   +  presidential +  urban.pct + rentierstate + taxstate +  unscheduled_election + state.owned.1lag + patronage.appts.1lag + antisys.1lag + regional_success_lag +  v2elembaut + (1 | stateid), data = nelda2.sub) 
#summary(m1a)

m1b <- lmer(v2elirreg.inv ~ jucon.1lag + legcon.1lag  + gdpgro.1lag +  osorg.1lag  + natlpartyorg.lag   + presidential   +   urban.pct + rentierstate + taxstate + physinteg.1lag + state.owned.1lag + patronage.appts.1lag + antisys.1lag + unscheduled_election + v2elembaut +  (1 | stateid), data = nelda2.sub) 

#summary(m1b)

m1c <- lmer(v2elirreg.inv ~ jucon.1lag + legcon.1lag + gdpgro.1lag +  osorg.1lag  + natlpartyorg.lag   +  presidential +  urban.pct + rentierstate + taxstate  + physinteg.1lag + physintlag.sq + state.owned.1lag + patronage.appts.1lag + antisys.1lag + unscheduled_election  + v2elembaut +  (1 | stateid), data = nelda2.sub) 
#summary(m1c)

m1 <- lmer(v2elirreg.inv ~ jucon.1lag + legcon.1lag + gdpgro.1lag +  osorg.1lag  + natlpartyorg.lag   +  presidential +  urban.pct + rentierstate + taxstate + n.events.pre  + state.owned.1lag + patronage.appts.1lag + antisys.1lag + unscheduled_election  + v2elembaut +  (1 | stateid), data = nelda2.sub) 

#summary(m1)

m1a <- lmer(v2elirreg.inv ~ jucon.1lag + legcon.1lag + gdpgro.1lag +  osorg.1lag  + natlpartyorg.lag   +  presidential +  urban.pct + rentierstate + taxstate +  unscheduled_election + state.owned.1lag + patronage.appts.1lag + antisys.1lag + regional_success_lag + v2elembaut +  (1 | stateid), data = nelda2.sub) 
#summary(m1a)

m1b <- lmer(v2elirreg.inv ~ jucon.1lag + legcon.1lag  + gdpgro.1lag +  osorg.1lag  + natlpartyorg.lag   + presidential   +   urban.pct + rentierstate + taxstate + physinteg.1lag + state.owned.1lag + patronage.appts.1lag + antisys.1lag +  unscheduled_election + v2elembaut +  (1 | stateid), data = nelda2.sub) 

#summary(m1b)

m1d <- lmer(v2elirreg.inv ~  libdem.1lag + gdpgro.1lag +    presidential +  urban.pct + rentierstate + taxstate  +  unscheduled_election + n.events.pre  + state.owned.1lag + patronage.appts.1lag + antisys.1lag + v2elembaut +  (1 | stateid), data = nelda2.sub) 
#summary(m1d)


modelsummary(c(m1, m1b, m1c, m1a), output = "kableExtra",  stars = T, gof_omit = c("R2|RMSE"), title = 'Table 2: Random-intercept multilevel model of election-day fraud', coef_omit = "SD", coef_rename = 
               c("jucon.1lag" = "Judical independence (lag)", "legcon.1lag" = "Leg. constraints (lag)", 
                 "gdpgro.1lag" = "GDP growth rate (lag)", "altinf.1lag" = "Alternative info. (lag)", 
                 "osorg.1lag" = "Civil soc. openness (lag)", "econ.crisis.nelda.1lag1" = "Economic crisis", 
                 "natlpartyorg.lag" = "National party organization (lag)", "presidential1" = "Presidential election",
                 "inc.termlimit.num" = "Incumbent term-limited", "libdem.1lag" = "Liberal democracy index (lag)", 
                 "urban.pct" = "Urbanization", "rentierstate" = "Rentier state", "taxstate" = "Tax state",
                 "n.events.massmob.pre" = "Number of pre-election protests", "median.participants.mm.pre" = "Median size of pre-election protests", "unscheduled_election" = "Off-schedule election",
                 "rentierstate1" = "Rentier state", "taxstate1" = "Tax state", "n.events.pre" = "Number of pre-election protests", "unscheduled_election1" = "Off-schedule election", "physinteg.1lag" = "Phys. integrity index (lag)",
                 "physintlag.sq" = "Phys. int. lag squared", "regional_success_lag" = "Regional protest diffusion", "antisys.1lag" = "Anti-system CS activity"
                 )) %>% kable_styling(latex_options = "HOLD_position")

##Note: state owned variable is inverse coded, so should be labeled as private ownership in economy
##Note: Patronage appointments ialso inverse coded. Higher values = more professionalism
```

\newpage




## Election-day fraud and protest risk

```{r models-hurdle-mm, warning = FALSE, message = FALSE, include = F}
model.n.novoteshare.hurd.mm <- glmmTMB::glmmTMB(n.events.post ~  jucon.1lag + legcon.1lag + altinf.1lag + libdem.1lag + gdpgro.1lag +  + osorg.1lag  + natlpartyorg.lag + v2elirreg.inv +  +    + v2elirreg.inv  + presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election  + regional_success_lag,
                                ziformula=~.,
                                data = nelda2.sub %>% filter(inc.lose == "0"),
                                family=truncated_nbinom2)
summary(model.n.novoteshare.hurd.mm)

model.n.base.hurd.mm <- glmmTMB(n.events.post ~ jucon.1lag + legcon.1lag + altinf.1lag + libdem.1lag + gdpgro.1lag +  + osorg.1lag  + natlpartyorg.lag + v2elirreg.inv +  +    winner.share.upd + v2elirreg.inv  + presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election + regional_success_lag,
                               ziformula=~.,
                              data = nelda2.sub %>% filter(inc.lose == "0"),
                                family=truncated_nbinom2)
summary(model.n.base.hurd.mm)

model.n.base2.hurd.mm <- glmmTMB::glmmTMB(n.events.post ~  jucon.1lag + legcon.1lag + gdpgro.1lag + altinf.1lag + libdem.1lag +  + osorg.1lag  + natlpartyorg.lag + v2elirreg.inv +  +    winner.share.upd*v2elirreg.inv  + presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election + regional_success_lag,
                                          zi = ~.,
                                          family= nbinom2,
                                          data = nelda2.sub %>% filter(inc.lose == "0"))
summary(model.n.base2.hurd.mm)



model.n.griev.hurd.mm <- glmmTMB::glmmTMB(n.events.post ~ jucon.1lag + legcon.1lag + gdpgro.1lag + altinf.1lag + libdem.1lag +  osorg.1lag +  natlpartyorg.lag + v2elirreg.inv +  v2elirreg.inv*gdpgro.1lag  + presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election + regional_success_lag ,
                                ziformula=~.,
                                data = nelda2.sub %>% filter(inc.lose == "0"),
                                family=truncated_nbinom2)
summary(model.n.griev.hurd.mm)



model.n.repr.hurd <- glmmTMB::glmmTMB(n.events.post ~ jucon.1lag + legcon.1lag + altinf.1lag + libdem.1lag +   + osorg.1lag +  natlpartyorg.lag + v2elirreg.inv  +  physinteg.1lag*v2elirreg.inv  + presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election + regional_success_lag,
                                ziformula=~.,
                                data = nelda2.sub %>% filter(inc.lose == "0"),
                                family=truncated_nbinom2)
summary(model.n.repr.hurd)
```









```{r models-hurdle-size, warning = FALSE, message = FALSE, include = F}
model.size.novoteshare <- glmmTMB::glmmTMB(max_size ~ jucon.1lag + legcon.1lag + osorg.1lag + altinf.1lag + libdem.1lag  + natlpartyorg.lag + v2elirreg.inv +  +   v2elirreg.inv  + presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election + regional_success_lag ,
                                ziformula=~.,
                                data = nelda2.sub %>% filter(inc.lose == "0"),
                                family=truncated_nbinom2)
summary(model.size.novoteshare)

model.size.base <- glmmTMB::glmmTMB(max_size ~ jucon.1lag + legcon.1lag + osorg.1lag + altinf.1lag + libdem.1lag  + natlpartyorg.lag + v2elirreg.inv +  +   v2elirreg.inv + winner.share.upd + presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election + regional_success_lag ,
                                ziformula=~.,
                                data = nelda2.sub %>% filter(inc.lose == "0"),
                                family=truncated_nbinom2)
summary(model.size.base)

model.size.base2 <- glmmTMB::glmmTMB(max_size ~ jucon.1lag + legcon.1lag + osorg.1lag + altinf.1lag + libdem.1lag  + natlpartyorg.lag + v2elirreg.inv + gdpgro.1lag  +   winner.share.upd*v2elirreg.inv  + presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election + regional_success_lag ,
                                ziformula=~.,
                                data = nelda2.sub %>% filter(inc.lose == "0"),
                                family=truncated_nbinom2)
summary(model.size.base2)

model.size.griev <- glmmTMB::glmmTMB(max_size ~ jucon.1lag + legcon.1lag + gdpgro.1lag + altinf.1lag + libdem.1lag +  osorg.1lag +  natlpartyorg.lag + v2elirreg.inv +  v2elirreg.inv*gdpgro.1lag  + presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election + regional_success_lag,
                                ziformula=~.,
                                data = nelda2.sub %>% filter(inc.lose == "0"),
                                family=truncated_nbinom2)
summary(model.size.griev)

```




```{r initiation-table-setup, echo=FALSE, results='asis', warning=FALSE, message=FALSE}

models_t1 <- list()
models_t1[['Model 5']] <- model.n.base.hurd.mm
models_t1[['Model 6']] <- model.n.base2.hurd.mm
models_t1[['Model 7']] <- model.n.griev.hurd.mm
#models_t1[['Model 5']] <- m_duration_count
#models_t1[['Model 6']] <- model.d.base2.hurd
#models_t1[['Model 7']] <- model.d.griev.hurd


t1a <- huxreg(models_t1, tidy_args = c("component" = "zi"), borders = 0, number_format = 2, coefs = c("Intercept" = "(Intercept)", "Judicial ind. (lag)" = "jucon.1lag", "Liberal democracy index" = "libdem.1lag",
            "Legislative constraints (lag)" = "legcon.1lag", "Alternative info. (lag)" = "altinf.1lag",                             "GDP growth rate (lag)" = "gdpgro.1lag",                               "Civil society openness (lag)" = "osorg.1lag", "National party organization (lag)" = "natlpartyorg.lag",                "Election fraud" = "v2elirreg.inv", "Winner vote-share" = "winner.share.upd", "Presidential" = "presidential1", "Incumbent term-limited" = "inc.termlimit.num",
            "Physical integrity (lag)" = "physinteg.1lag", "Phys. int. (lag) squared" = "physintlag.sq",
            "Urban" = "urban.pct", "Rentier state" = "rentierstate1", "Tax state" = "taxstate1"),
              statistics = character(0))  %>% set_caption("Table 3: Zero-inflated models of no protest initiation")

theme_compact(t1a, header_rows = TRUE, header_cols = FALSE)





t1b <- huxreg(models_t1, tidy_args = c("component" = "zi"), borders = 0, number_format = 2, coefs = c("Number of pre-election protests" = "n.events.pre", "Off-schedule election" = "unscheduled_election1", "Regional protest diffusion" = "regional_success_lag", "Election fraud : Winner vote-share" = "v2elirreg.inv:winner.share.upd", "Election fraud : GDP growth (lag)" = "gdpgro.1lag:v2elirreg.inv")) %>% set_caption("Table 3 cont.: Zero-inflated models of no protest initiation") 

t1b <- huxtable::add_footnote(t1b, "Note: Negative coefficients indicate protest is more likely.")


theme_compact(t1b, header_rows = TRUE, header_cols = FALSE)
```





```{r conditional-table, echo=FALSE, results='asis', warning=FALSE, message=FALSE}
models_t2 <- list()
models_t2[['Model 5']] <- model.n.base.hurd.mm
models_t2[['Model 6']] <- model.n.base2.hurd.mm
models_t2[['Model 7']] <- model.n.griev.hurd.mm
models_t2[['Model 8']] <- model.size.base
models_t2[['Model 9']] <- model.size.base2
models_t2[['Model 10']] <- model.size.griev


t2a <- huxreg(models_t2, tidy_args = c("component" = "cond"), borders = 0, number_format = 2, stars = c(`***` = 0.001, `**` = 0.01, `*` = 0.05, `+` = .1), coefs = c("Intercept" = "(Intercept)", "Judicial ind. (lag)" = "jucon.1lag",
            "Legislative constraints (lag)" = "legcon.1lag", "Alternative info. (lag)" = "altinf.1lag",                             "Liberal democracy index (lag)" = "libdem.1lag", "GDP growth rate (lag)" = "gdpgro.1lag",                               "Civil society openness (lag)" = "osorg.1lag", "National party organization (lag)" = "natlpartyorg.lag",                "Election fraud" = "v2elirreg.inv", "Winner vote-share" = "winner.share.upd", "Presidential" = "presidential1", "Incumbent term-limited" = "inc.termlimit.num",
            "Physical integrity (lag)" = "physinteg.1lag", "Phys. int. (lag) squared" = "physintlag.sq",
            "Urban" = "urban.pct", "Rentier state" = "rentierstate1", "Tax state" = "taxstate1"), statistics = character(0)) %>% set_caption("Table 4: Negative binomial models of number and duration of protests") %>% insert_row("", "", "Number", "", "", "Size", "", after = 0)


theme_compact(t2a, header_rows = TRUE, header_cols = FALSE)


t2b <- huxreg(models_t2, tidy_args = c("component" = "cond"), borders = 0, number_format = 2, stars = c(`***` = 0.001, `**` = 0.01, `*` = 0.05, `+` = .1), coefs = c("Number of pre-election protests" = "n.events.pre", "Off-schedule election" = "unscheduled_election1", "Regional protest diffusion" = "regional_success_lag", "Election fraud : Winner vote-share" = "v2elirreg.inv:winner.share.upd", "Election fraud : GDP growth (lag)" = "gdpgro.1lag:v2elirreg.inv")) %>% set_caption("Table 4 cont.: Negative binomial models of number and duration of protests") %>% insert_row("", "", "Number", "", "", "Size", "", after = 0)


theme_compact(t2b, header_rows = TRUE, header_cols = FALSE)


#modelsummary::modelsummary(models, shape = term + estimate + component ~ model, coef_omit = "count", gof_omit = "R2", stars = T, longtable=T,  title = 'Binary portion of hurdle models of post-election protest', coef_rename = 
#               c("zero_(Intercept)" = "Intercept", "zero_jucon.1lag" = "Judical independence (lag)", "zero_legcon.1lag" = "Leg. constraints (lag)", 
#                 "zero_gdpgro.1lag" = "GDP growth rate (lag)", "zero_altinf.1lag" = "Alternative info. (lag)", 
#                 "zero_osorg.1lag" = "Civil soc. openness (lag)", "zero_econ.crisis.nelda.1lag1" = "Economic crisis", 
#                 "zero_natlpartyorg.lag" = "National party organization (lag)", "zero_presidential1" = "Presidential election",
#                 "zero_inc.termlimit.num" = "Incumbent term-limited",  
#                 "zero_urban.pct" = "Urbanization", "zero_rentierstate" = "Rentier state", "zero_taxstate" = "Tax state",
#                 "zero_n.events.pre" = "Number of pre-election protests", "zero_pubseccorrup.lag" = "Public sector corruption (lag)", "zero_v2elirreg.inv" = "Election fraud",
#                 "zero_physinteg.1lag" = "Physical integrity (lag)", "zero_physintlag.sq" = "Physical integrity (lag), squared", "zero_winner.share.upd" = "Incumbent vote-share", "v2elirreg.inv" = "Election fraud", "zero_unscheduled_election" = "Off-schedule election")) # %>%
#  add_header_above(c(" " = 1, "Protest quantity" = 3, "Maximum protest size" = 3))


```



\doublespace

The second set of models challenge the idea that more severe electoral manipulation is associated with an increased risk of anti-government protest. Beginning with the zero-inflation portion of the hurdle models in Table 3, which model the likelihood of *no* protest occurring after the election, the standalone coefficient for election fraud is not significant in Model 5. Figure \@ref(fig:margin-plot-gdp) shows that there are no significant effect across values of *lagged GDP growth*.  

More fraudulent elections do appear associated with an increasing risk of protest initiation as margins of victory shrink, as shown in the top panel of Figure  \@ref(fig:margin-prob-fig). Here, typical values for low and high levels of fraud are used (one standard deviation below and above the mean, respectively). The top panel shows that more fraudulent elections are associated with a significantly higher risk of protest initiation, but only when winning vote-shares are extremely small. 






\newpage


\singlespace



```{r include=FALSE}
nelda2.sub <- nelda2.sub %>% mutate(no_protest = ifelse(n.events.post == 0, 1, 0))
nelda2.sub <- nelda2.sub %>% mutate(no_size = ifelse(max_size == 0, 1, 0))




model.margin.binary_n <- glm(no_protest ~ jucon.1lag + legcon.1lag + gdpgro.1lag + altinf.1lag + libdem.1lag +  + osorg.1lag  + natlpartyorg.lag + v2elirreg.inv +  +    winner.share.upd*v2elirreg.inv  + presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election + regional_success_lag, family = binomial(link = "logit"), data = nelda2.sub %>% filter(inc.lose == "0"))
summary(model.margin.binary_n)

model.margin.binary_size <- glm(no_size ~ jucon.1lag + legcon.1lag + gdpgro.1lag + altinf.1lag + libdem.1lag +  + osorg.1lag  + natlpartyorg.lag + v2elirreg.inv +  +    winner.share.upd*v2elirreg.inv  + presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election, family = binomial(link = "logit"), data = nelda2.sub %>% filter(inc.lose == "0"))
summary(model.margin.binary_size)


model.binary.griev1_n <- glm(no_protest ~ jucon.1lag + legcon.1lag + gdpgro.1lag + altinf.1lag + libdem.1lag +  osorg.1lag +  natlpartyorg.lag + v2elirreg.inv +  +   gdpgro.1lag*v2elirreg.inv  + presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election, family = binomial(link = "logit"), data = nelda2.sub %>% filter(inc.lose == "0"))
summary(model.binary.griev1_n)

model.binary.griev1_size <- glm(no_size ~ jucon.1lag + legcon.1lag + gdpgro.1lag + altinf.1lag + libdem.1lag +  osorg.1lag +  natlpartyorg.lag + v2elirreg.inv +  +   gdpgro.1lag*v2elirreg.inv  + presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election, family = binomial(link = "logit"), data = nelda2.sub %>% filter(inc.lose == "0"))
summary(model.binary.griev1_size)



model.binary.repr_n <- glm(no_protest ~ jucon.1lag + legcon.1lag + gdpgro.1lag + altinf.1lag + libdem.1lag +  osorg.1lag +  natlpartyorg.lag + v2elirreg.inv + physinteg.1lag*v2elirreg.inv  + presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election, family = binomial(link = "logit"), data = nelda2.sub %>% filter(inc.lose == "0"))
summary(model.binary.repr_n)

## Plots

####Margin

#plot_binary_margin_max <- sjPlot::plot_model(model.margin.binary, type = "pred", terms = c("winner.share.upd [all]", "v2elirreg.inv [-2.3, 3.2]"))
#plot_binary_margin_max <- plot_binary_margin_max +  labs(x = "", y = "Predicted probability", title = "Predicted probability of any protest", color = "Election fraud") + theme_bw()

plot_binary_margin_typ_n <- sjPlot::plot_model(model.margin.binary_n, type = "pred", terms = c( "winner.share.upd", "v2elirreg.inv [-1.5, 1.5]"), show.data = T)
plot_binary_margin_typ_n <- plot_binary_margin_typ_n +  labs(x = "Incumbent vote-share", y = "Predicted probability", title = "Predicted probability of no protest", color = "Election fraud") + theme_bw()





###GDP



plot_binary_gdp_typ_n <- sjPlot::plot_model(model.binary.griev1_n, type = "pred", terms = c("v2elirreg.inv", "gdpgro.1lag [-0.04, .08]"))
plot_binary_gdp_typ_n <- plot_binary_gdp_typ_n +  labs(x = "Election fraud", y = "Predicted probability", title = "Predicted probability of no protest", color = "GDP growth (lagged)") + theme_bw() 



## Repression


plot_binary_repr_typ_n <- sjPlot::plot_model(model.binary.repr_n, type = "pred", terms = c("v2elirreg.inv", "physinteg.1lag [.25, .61]"))
plot_binary_repr_typ_n <- plot_binary_repr_typ_n +  labs(x = "Election fraud", y = "Predicted probability", title = "Predicted probability of any protest", color = "Physical integrity (lagged)") + theme_bw()

```

```{r margin-plot-gdp, echo=FALSE, message=F, warning=FALSE, fig.cap="Marginal effect of election fraud on protest initiation, conditional on lagged GDP growth"}
plot_binary_gdp_typ_n
```



```{r n-protests-margin, fig.cap="Fraud, incumbent vote-share, and number of protest events", echo=FALSE, message=FALSE}
dat <- ggpredict(model.n.base2.hurd.mm, terms = c("winner.share.upd [0, .1, .2, .3, .4, .5, .6, .7, .8, .9, 1]", "v2elirreg.inv [-1.5, 1.5]"), type = "count") 
p.n.margin <- plot(dat)
p.n.margin <- p.n.margin +  labs(x = "Incumbent vote-share", y = "Number of events", title = "Predicted number of protests", color = "Election fraud") + theme_bw()
```

```{r margin-prob-fig, fig.cap="Fraud, winning vote-share, and probability of protest initiation", fig.height=7, echo=FALSE, message=FALSE, fig.pos='H'}
plot.combined.prob <- cowplot::plot_grid(plot_binary_margin_typ_n, p.n.margin, ncol=1)
plot.combined.prob
```




\newpage

## The number and size of post-election protests

\doublespace

Results from the models of number and size of protest events, conditional on protest initiation, are shown in Table 4. Models 5 and 8 show no significant relationship between fraud and and the number or maximum size of protest events. The bottom panel of Figure \@ref(fig:margin-prob-fig) shows the marginal effect of election fraud on the number of protests, given varying levels of winning vote-share, holding other variables constant at their means (continuous variables) or modes (categorical variables). As the figure shows, there is no statistically significant difference in the expected number of protests. No significant effects are found for fraud and GDP growth in Models 7 or 10. Nor is there a significant effect for fraud on protest size, conditional on margin of victory. However, Hypothesis 6 is consistently supported\textemdash incumbent term limits do seem associated with increased size and number of post-election protests.


Altogether, there is scant evidence to support the argument that protest risk deters election fraud. Models 1 through 4 show that various measures of pre-election protest risk are not associated with reduced fraud\textemdash in fact, some appear to increase the severity of fraud. Models 6 through 11 show that higher levels of fraud is not "punished" by more or larger protests. Hypothesis 2 is supported, but very weakly; there is a significant association between election fraud and protest initiation, but only when the incumbent's winning vote-share is near its minimum. However, even this supportive finding likely presents too optimistic a picture for the protest-deterrent model of election fraud. The number and size results from the hurdle regressions show no effect for election fraud across any of the models, alone or in interaction. Even when protests are initiated\textemdash a relatively rare event in the first place\textemdash the size of a protest wave is not influenced by the degree of fraud perpetrated by the ruling party. In turn, this suggests two pessimistic interpretations of fraud-protest dynamic. First, protest may simply be less damaging to ruling parties than is regularly assumed in theories of election manipulation. Faced with a nascent protest movement, ruling parties are generally able to contain, co-opt, or repress them\textemdash regardless of the severity of election fraud. An even more troubling implication would suggest that the protest-manipulation logic, rather than serving as a deterrent, creates perverse incentives to manipulate as much as possible. If ruling parties do indeed seek to avoid protest initiation, but manipulating heavily does not entail more severe protest, ruling parties have an incentive fraudulently inflate their official margins of victory in order to reduce the risk of protest initiation.   


```{r pred-size, fig.cap="Fraud, winning vote-share, and predicted number of protests", fig.height=7, echo=FALSE, message=FALSE, fig.pos='H'}

p.protestlow <- sjPlot::plot_model(model.n.base2.hurd.mm, type = "pred", terms = c("winner.share.upd", "v2elirreg.inv [1.5]"), condition = c(n.events.pre = 0)) + labs(x = "Incumbent vote-share", y = "", title = "Predicted n of post-election protests (Pre-\nelection protest: 5th percentile)") + coord_cartesian(ylim = c(0, 20))


p.protesthigh <- sjPlot::plot_model(model.n.base2.hurd.mm, type = "pred", terms = c("winner.share.upd", "v2elirreg.inv [1.5]"), condition = c(n.events.pre = 8)) + labs(x = "Incumbent vote-share", y = "", title = "Predicted n of post-election protests (Pre-\nelection protest: 95th percentile)") + coord_cartesian(ylim = c(0, 20))

cowplot::plot_grid(p.protestlow, p.protesthigh, nrow = 1)
```



```{r pred-size, fig.cap="Fraud, winning vote-share, and predicted max protest size", fig.height=7, echo=FALSE, message=FALSE, fig.pos='H'}

p.protestlow <- sjPlot::plot_model(model.size.base2, type = "pred", terms = c("winner.share.upd", "v2elirreg.inv [1.5]"), condition = c(n.events.pre = 0)) + labs(x = "Incumbent vote-share", y = "Max. size", title = "Predicted max. size (Pre-\nelection protest: 5th percentile)") + coord_cartesian(ylim = c(0, 8000))


p.protesthigh <- sjPlot::plot_model(model.size.base2, type = "pred", terms = c("winner.share.upd", "v2elirreg.inv [1.5]"), condition = c(n.events.pre = 8)) + labs(x = "Incumbent vote-share", y = "", title = "Predicted max. size (Pre-\nelection protest: 95th percentile)") + coord_cartesian(ylim = c(0, 8000))

cowplot::plot_grid(p.protestlow, p.protesthigh, nrow = 1)
```


```{r zero-model-table-count, echo=FALSE}
#modelsummary::modelsummary(models, coef_omit = "zero", gof_omit = "R2", longtable=T, stars = T, title = 'Hurdle models of post-election protest (counts)',
#                           coef_rename = 
 #              c("count_(Intercept)" = "Intercept", "count_jucon.1lag" = "Judical independence (lag)", "count_legcon.1lag" = "Leg. constraints (lag)", 
#                 "count_gdpgro.1lag" = "GDP growth rate (lag)", "count_altinf.1lag" = "Alternative info. (lag)", 
#                 "count_osorg.1lag" = "Civil soc. openness (lag)", "count_econ.crisis.nelda.1lag1" = "Economic crisis", #
#                 "count_natlpartyorg.lag" = "National party organization (lag)", "count_presidential1" = "Presidential election",
#                 "count_inc.termlimit.num" = "Incumbent term-limited",  
#                 "count_urban.pct" = "Urbanization", "count_rentierstate" = "Rentier state", "count_taxstate" = "Tax state",
#                 "count_n.events.pre" = "Number of pre-election protests", "count_pubseccorrup.lag" = "Public sector corruption (lag)", "count_v2elirreg.inv" = "Election fraud",
#                 "count_physinteg.1lag" = "Physical integrity (lag)", "count_physintlag.sq" = "Physical integrity (lag), squared", "count_winner.share.upd" = "Incumbent vote-share", "v2elirreg.inv" = "Election fraud", "count_unscheduled_election" = "Off-schedule election"))

```


One objection to this framing could be: perhaps the null result found for the number and size of protests is the result of equilibrium behavior predicted in many formal models. The threat of protest keeps fraud lower than it would be otherwise, resulting in limited (if any) protest. In some states, this equilibrium level of fraud is higher than in others, resulting in no correlation between fraud and observed protest. There are three reasons to be skeptical of this interpretation, two empirical and one substantive.  

First, such an objection does not account for the unexpected results found in Models 1 through 4, where indicators of pre-election protest risk were found to be associated with more severe election-day fraud. Second, deterrence models would expect the equilibrium level of fraud to fall as protest risk increases, and for more severe protest to occur as a result of miscalculation by the regime. We can test this by examining the predicted intensity of protest from the models specified here. If the severity of fraud is held constant at a high level while underlying protest risk increases, we should see an increase in the predicted protest outcome. Taking protest size as an example, using Model 9, Figure \@ref(fig:pred-size) shows there is no evidence of such an effect. Both panels show the marginal effect of a relatively fraudulent election (*election fraud* is set to one standard deviation above the mean) on the predicted maximum protest size, conditional on the closeness of the election result. All control variables have been set to their means or modes with the exception of *pre-election protest*. In the left panel, the quantity of pre-election protest has been set to the fifth percentile for that variable (0 events), on the right, it has been set to the 95th percentile (8 events). An equilibrium approach would suggest that high fraud is more dangerous in the more active protest envionment captured on the right, especially at low levels of *winner's vote-share*. However, we see practically no difference in the predicted maximum protest size across the different conditions modeled here\textemdash changing protest conditions do not appear to affect the 'appropriate' level of fraud, throwing cold water on the equilibrium argument. 

Substantively, even if one does not fully discount the claim that the null results shown here represent equilibrium behavior, it is difficult to dispute that the resulting outcome is weighted heavily in favor of governments. In the dataset of 1110 elections used here, only 19 elections in five countries are coded as having an *intentional irregularities* score of less than -2 (indicating extremely fraud-free elections). By contrast, 121 elections in 27 countries score higher than 2 (indicating highly fraudulent elections). The frequency of fraud, the rarity of protest, and the finding that fraud severity is not correlated with the scope of protest events all point to the same conclusion: protest risk is not a substantial constraint on election fraud in electoral authoritarian and electoral democratic regimes.






# A further test: protest wave duration

```{r, include=FALSE}
library(survival)
library(ggsurvfit)
nelda2.sub <- nelda2.sub %>% mutate(surv_status = ifelse(d.events.num > 0, 1, NA))
nelda2.sub <- nelda2.sub %>% mutate(fraud_level = ifelse(v2elirreg.inv >= (.98 + .97), "High",
                                                            ifelse(v2elirreg.inv <= (.98 - .97), "Low", "Moderate")))

nelda2.sub.km <- nelda2.sub %>% filter(inc.lose == "0") %>% filter(d.events.num > 0 & inc.replaced.prot == 0)


km <-  with(nelda2.sub.km, Surv(d.events.num, surv_status))

survfit2(Surv(d.events.num, surv_status) ~ 1, data = nelda2.sub.km %>% filter(d.events.num < 300)) %>% 
  ggsurvfit() +
#   add_confidence_interval() +
  labs(
    x = "Days",
    y = "Overall survival probability"
  )

survfit2(Surv(d.events.num, surv_status) ~ fraud_level, data = nelda2.sub.km %>% filter(d.events.num < 300)) %>% 
  ggsurvfit() +
#   add_confidence_interval() +
  labs(
    x = "Days",
    y = "Overall survival probability"
  )

cox1 <- coxph(Surv(d.events.num, surv_status) ~ jucon.1lag + legcon.1lag + altinf.1lag + libdem.1lag +  osorg.1lag + gdpgro.1lag + natlpartyorg.lag + winner.share.upd  + presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + n.events.post + unscheduled_election + regional_success_lag + v2elirreg.inv , data = nelda2.sub %>% filter(inc.lose == "0" & n.events.post > 0 & inc.replaced.prot == 0))
summary(cox1)
cz1 <- cox.zph(cox1, transform = "identity")
print(cz1)
plot(cz1[19])
abline(h=0)
abline(v = 21)
abline(v = 61)




cox1t <- coxph(Surv(d.events.num, surv_status) ~ jucon.1lag + legcon.1lag + altinf.1lag + libdem.1lag +  osorg.1lag + gdpgro.1lag + natlpartyorg.lag + winner.share.upd + presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election + n.events.post + regional_success_lag + v2elirreg.inv + tt(v2elirreg.inv), data = nelda2.sub %>% filter(inc.lose == "0") %>% filter(d.events.num > 0 & inc.replaced.prot == 0), tt = function(x, t, ...)  x* nsk(t, knots=c(21, 61, 90),
Boundary.knots = FALSE))
summary(cox1t)

cz <- cox.zph(cox1, transform = "identity") #function(time) 1/(log(time + 1)))
print(cz)
plot(cz) # The points on the plot are residuals of v2elirreg.inv (and other vars) based on hte predicted value of X and time t. The line shows the estimated value of the coefficient on variable X at time t compared to its baseline. You want it to be zero for consistent effects over time. V2elirreg.inv is positive for about two weeks early on. The substantive effect of this can be shown by taking two values of v2elirreg.inv (i.e. first and third quartile), taking the difference, and finding exp(coefficient_residual * difference). The result shows here that protests in states in the third quartile of fraud are exp(.75*1.4) = 2.86 times more likely to die than those in the first quartile during those couple weeks. So this suggests that if protests survive the first week or two, the state's capacity starts to kick in?

sandbox_data <- survSplit(Surv(d.events.num, surv_status) ~ 
                      jucon.1lag + legcon.1lag + altinf.1lag + libdem.1lag +  osorg.1lag + gdpgro.1lag + natlpartyorg.lag + fraud_level + winner.share.upd + presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election + regional_success_lag,
                      data = nelda2.sub %>% filter(inc.lose == "0") %>% filter(d.events.num > 0 & inc.replaced.prot == 0), cut = c(2), episode = "tgroup")


cox1.2 <- coxph(Surv(d.events.num, surv_status) ~ jucon.1lag + legcon.1lag + altinf.1lag + libdem.1lag +  osorg.1lag + gdpgro.1lag + natlpartyorg.lag + fraud_level*(as.factor(tgroup)) + winner.share.upd + presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election + regional_success_lag, data = sandbox_data)
summary(cox1.2)





cox2 <- coxph(Surv(d.events.num, surv_status) ~ jucon.1lag + legcon.1lag + altinf.1lag + libdem.1lag +  osorg.1lag + gdpgro.1lag + natlpartyorg.lag + v2elirreg.inv*winner.share.upd  + presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election + regional_success_lag + n.events.post, data = nelda2.sub %>% filter(inc.lose == "0") %>% filter(d.events.num > 0 & inc.replaced.prot == 0))
summary(cox2)
sjPlot::plot_model(cox2, type = "pred", terms = c("winner.share.upd", "v2elirreg.inv [-.15, 2.27]")) + coord_cartesian(ylim = c(0, 10)) #This is the 10th and 90th quantiles


cox3 <- coxph(Surv(d.events.num, surv_status) ~ jucon.1lag + legcon.1lag + altinf.1lag + libdem.1lag +  osorg.1lag + gdpgro.1lag + natlpartyorg.lag + gdpgro.1lag*v2elirreg.inv  + presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election + regional_success_lag , data = nelda2.sub %>% filter(inc.lose == "0") %>% filter(d.events.num > 0 & inc.replaced.prot == 0))
summary(cox3)

cox4 <- coxph(Surv(d.events.num, surv_status) ~ jucon.1lag + legcon.1lag + altinf.1lag + libdem.1lag +  osorg.1lag + gdpgro.1lag + natlpartyorg.lag + v2elirreg.inv*winner.share.upd  + presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election + regional_success_lag, data = nelda2.sub %>% filter(inc.lose == "0") %>% filter(d.events.num > 0))
summary(cox4)

```


```{r}
library(survsim) #Looking at time invariance
zph <- cox.zph(cox1)
zph

plot(zph[19], lwd =2)
abline(0,0, col=1, lty = 3, lwd = 2)
abline(h = cox1$coefficients[19], col=3, lwd=2, lty=2)
```


To further test the mechanism outlined in the theory above, I examine the relationship between fraud and the survival of protest movements in cases where protests began but the incumbent eventually survived. Restricting the sample to these cases allows for a consistent interpretation of results: longer protest waves indicate a more even match between the resources and resiliency of the protesters and the capacity and cohesiveness of the regime, while shorter-lived protest movements are those which were more easily defeated. In this sub-sample, the relationship between election fraud and protest survival should be non-linear with respect to time\textemdash the longer the protest movement survives, the less relevant the fraud signal (such as it is) becomes. That is, any effect of fraud on protest should decline in size and and become statistically insignificant as the election recedes. 

Table 5 reports the results of Cox proportional hazard models of protest duration; coefficients with a negative sign indicate factors that are associated with longer-lived protest movements; those with a positive sign indicate factors associated with a speedier demise. 

In Model 11, all covariates' effects are modeled as time-invariant. However, diagnostics of the model suggest that this assumption may not be upheld for *election fraud*.^[Schoenfeld residuals for *election fraud* are not independent of time, as calculated using the `survival` package in R [@survival-package].] To adjust for this, Model 12 allows the coefficient for *election fraud* to take on different values at different points in time. Based on the diagnostics, I allow the value of the coefficient to vary for three periods: 1 - 11 days, 12 - 25 days, and 26 days to the maximum value. Model 12 shows the result of this analysis; in it, *election fraud* has a positive and significant coefficient for the earliest time period. This indicates that, for the first 11 days of a protest movement, states that engaged in more election fraud are more likely to be able to quash the protests (whether by repression or accommodation). This is contrary to the expectations of deterrence models. After this period, there is no significant relationship between the level of fraud and the survival of the protest wave. That is, if a protest movement has survived longer than (roughly) a week and a half after the election, the severity of fraud does not influence its continued duration. It is also noteworthy that this formulation is a much better fit to the data than the linear effect in Model 11, with a much lower root mean square error.

These results indicate that the influence of a fraudulent election on the duration of mass protest diminishes over time. It also suggests that most protests are failed bets. Upon taking to the streets, protesters are more likely to find themselves facing a capable incumbent regime the more fraudulent the election was. Finally, if protests survive beyond the short term, the severity of fraud no longer has any effect. Instead, structural indicators\textemdash the strength of the opposition in the legislature, the degree to which parties are organized across the country, and (to a lesser extent) the openness of civil society are all associated with longer-lived protest movements. Similarly, a more fractured incumbent regime, as indicated by a term-limited incumbent, also make protest survival more likely. All of this is supportive of the theoretical model laid out above.

```{r cox-models-tab, echo=FALSE, warning=FALSE}
models3 <- list()
models3[['Model 11']] <- cox1
models3[['Model 12']] <- cox1t
#models3[['Model 14']] <- cox3




modelsummary::modelsummary(models3, gof_omit = "AIC|BIC|Log", longtable=F, stars = T, title = 'Table 5: Cox proportional hazard models of protest duration', coef_rename = 
               c("jucon.1lag" = "Judical independence (lag)", "legcon.1lag" = "Leg. constraints (lag)", 
                 "gdpgro.1lag" = "GDP growth rate (lag)", "altinf.1lag" = "Alternative info. (lag)", 
                 "osorg.1lag" = "Civil soc. openness (lag)", 
                 "winner.share.upd" = "Incumbent vote-share",
                 "natlpartyorg.lag" = "National party organization (lag)", "presidential1" = "Presidential election",
                 "inc.termlimit.num" = "Incumbent term-limited", "libdem.1lag" = "Liberal democracy index (lag)", 
                 "urban.pct" = "Urbanization", "rentierstate" = "Rentier state", "taxstate" = "Tax state",
                 "n.events.massmob.pre" = "Number of pre-election protests", "median.participants.mm.pre" = "Median size of pre-election protests", "unscheduled_election" = "Off-schedule election",
                 "rentierstate1" = "Rentier state", "taxstate1" = "Tax state", "n.events.pre" = "Number of pre-election protests", "unscheduled_election1" = "Off-schedule election", "physinteg.1lag" = "Phys. integrity index (lag)",
                 "physintlag.sq" = "Phys. int. lag squared", "regional_success_lag" = "Regional protest diffusion", "v2elirreg.inv" = "Election fraud",
                 "tt(v2elirreg.inv)1" = "Election fraud (day 2-20)", "tt(v2elirreg.inv)2" = "Election fraud (day 21-90)"
                 ))

```


\doublespace

# Discussion

Altogether, the findings challenge the idea that the fear of protest helps deter election manipulation. To the extent that fraud is a signal of incumbent strength, it is an unreliable one. Since even strong incumbents commit fraud, the decision to take to the streets is often a losing gamble\textemdash anticipating a weak incumbent, they instead find one that is capable of repressing, coopting, or conciliating an emerging protest movement. Indeed, while there are 194 cases of protest out of the 661 elections in this dataset where incumbents claimed victory, only 8 resulted in either the incumbent being replaced or the election being re-run due to mass protests.\footnote{This information is determined using the NELDA variables NELDA37 and NELDA41.} This suggests a `success rate' for post-election protest of about four percent *conditional on protest initiation*, and about one percent for all elections in electoral authoritarian and electoral democratic regimes. 

The results indicate that we should be cautious when building and interpreting theories of politics outside liberal democratic regimes that emphasize the risk of mass protest as a trip-wire to be avoided, and add empirical evidence to Przeworski's [-@przeworskiFormalModelsAuthoritarian2022] critique of such models. The rarity of post-election protest, especially successful protest, suggests that such events are highly contingent; they hinge on a multitude of factors that go beyond the regime's efforts to bias election outcomes. Both protest and election fraud are complex phenomena with multiple drivers, including resource costs, signaling, information-gathering, principal-agent dynamics, and more; these findings indicate that protest risk is not a significant factor under most circumstances. 


This has several implications for understanding election manipulation and regime resilience. By overlooking the poor quality of election fraud as a signal, or by treating protest primarily as a binary event, the existing literature on electoral protest has overemphasized the risk to incumbents of engaging in electoral manipulation. The results presented here show that fraud has no bearing on how numerous or large protest events are. Moreover, heightened protest risk appears to be associated with *more* election fraud, rather than less. Instead, the conditions that are correlated with more damaging protest are generally institutional factors, especially executive term limits, which are either more amenable to control or can be anticipated by incumbents. 

These are pessimistic findings for proponents of democracy. That electoral protest is less risky than is often assumed, in turn, implies that governments and ruling parties have a freer hand to engage in electoral manipulation than many models posit. Since the severity of fraud has no apparent bearing on whether or not a major protest wave will emerge as a serious threat to the regime, government have an incentive to manipulate as much as possible to secure a large winning vote-share. This perverse incentive undermines the case that free and fair elections in an electoral democracy represent a self-enforcing equilibrium backed up by the risk of citizen protest [@fearon_self-enforcing_2011], or that risk of popular mobilization can substantially moderate election manipulation in non-democracies. In effect, it is the existence of an election itself [@lucardiStrengthExpectationElections2019], and the opportunity it offers for opposition mobilization [@howard2006], that creates protest risk for incumbents, giving them a relatively free hand to manipulate to the extent they can recruit agents to do the work. 

This study also suggests implications for the study of election manipulation. First, the study implies that supply-side theories of electoral manipulation\textemdash such as resource availability [@greene_why_2007], principal-agent problems [@rundlett2016deliver], and legal risks to manipulators [@Harvey2022]\textemdash may be more important than protest risk for understanding election integrity, which may drive future research as well as policy interventions. Third, and relatedly, it undermines some current understandings of the role of election monitors, courts, and other third parties in upholding election integrity. As noted earlier, prior studies argue that these actors restrain manipulation by revealing information about fraud and intensifying protest risk. But if protest risk is largely untethered from the severity of fraud, it is likely that other mechanisms are at work. Scholarly attention might turn more profitably toward supply-side explanations for manipulation, such as the organizational capacity of the state [@simpser2013], the popularity of the government [@rundlett2016deliver], and the risks faced by front-line agents [@Harvey2022]. 

Second, it suggests avenues for future research. It is clear that electoral protests charged by allegations of manipulation do occur at times. While the main argument of this paper is that election fraud itself does not predict these protests, there may still be connections between manipulation and protest to uncover. For example, it could be that other forms of manipulation\textemdash perhaps intimidation or violence\textemdash are associated with higher risk of escalating protest. Perhaps some forms of electoral manipulation are particularly offensive to certain groups\textemdash young people, highly educated people, people with ideological commitments to democracy, etc. To the extent that countries vary according to the size of such populations, they may vary in their underlying protest risk. 

As a final point, the results also speak to incidents of mobilization around unfounded allegations of election-rigging, such as those of January 6, 2020 in the United States or 2022-2023 in Brazil. Indeed, out of the 293 instances of post-election protest in this dataset, 18 occurred after very clean elections (those one standard deviation below the mean for election fraud)\textemdash a small but not minuscule percentage. These incidents demonstrate that, while crying fraud may sometimes be a useful tool for protest entrepreneurs, losing an election alone can be a catalyst for protest, irrespective of the actual level of election manipulation. This possibility tends to reduce the 'opportunity cost' to incumbents of engaging in real fraud, while also underlining the fact that the initiation and course of protest is often driven more by the relative resources and opportunities available to the disaffected and the incumbent government.

These results are consistent with different specifications presented in an online appendix. In particular, the main results are supported when data from the Mass Mobilization dataset are used in place of the ECAV data (appendix page 1), and when a measure of overall election integrity is used in place of the measure of election fraud (appendix page 15). 





# Conclusion

Protest risk is often considered to be a major risk to incumbent governments aiming to rig elections. This risk has a central role in several prominent models of electoral manipulation, serving to deter manipulation and to incentivize the toleration of election monitors and other restraints on the ruling party. However, I argue that such models overlook the ambiguity inherent in election manipulation efforts, as well as the quick decay of even such limited information once protests begin. Empirical research on the subject has largely treated protest as a binary variable, an approach which obscures the distinction between small, one-off protests and much more costly protest waves.

This paper addresses these concerns by testing the relationship between election fraud and the number and maximum size of protest events that occur after an election. Drawing on data from the V-Dem, NELDA, and ECAV datasets, it uses cross-national data on 1110 elections to show that election fraud has no significant relationship with the number or size of protests that occur in a protest wave. Additional tests suggest that this null finding is not the result of equilibrium behavior predicted in deterrence models. Instead, most fraudulent elections go un-protested, and most post-election protests appear to be strategic gambles gone wrong. The initiation of protest more often reveals the incumbent to be strong enough to manage protest through repression, cooptation, or other concessions. The results suggest that theories which treat protest risk as an unqualified deterrent to election manipulation should be reconsidered.

The absence of protest risk as a guardrail is felt in both electoral authoritarian regimes and in electoral democracies\textemdash those democracies that are most at risk of democratic erosion. The evidence thus suggests that mass demonstrations in favor of advancing (or restoring) democratic elections are rare and unlikely to be driven by the severity of manipulation---a gloomy picture for supporters of democratization---and that researchers should consider other mechanisms beyond mass protest in their models of electoral manipulation.

```{r, include=FALSE}
ggplot(data=nelda2.sub, aes(x=v2elirreg.inv, y = jitter(any.ecav.protest), color = as.factor(v2x_regime))) +
  geom_point()

```

This is an attempt at modeling endogenous relationships using two-step residual inclusion regression:

```{r}
nelda2.sub <- nelda2.sub %>% mutate(any_protest = ifelse(n.events.post > 0, 1, 0))

test_model <- OneSampleMR::tsri(any_protest ~ v2elirreg.inv | jucon.1lag + legcon.1lag + gdpgro.1lag + altinf.1lag + libdem.1lag +   osorg.1lag  + natlpartyorg.lag  +  presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election + regional_success_lag, data = nelda2.sub, link = "logit")
summary(test_model)


test_model2 <- OneSampleMR::tsri(any_protest ~ winner.share.upd | v2elirreg.inv +  jucon.1lag + legcon.1lag + gdpgro.1lag + altinf.1lag + libdem.1lag +   osorg.1lag  + natlpartyorg.lag  +  presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election, data = nelda2.sub, link = "logit")
summary(test_model2)

```

Predicting post-election protest counts and getting residuals:

```{r}
test3 <- glm.nb(n.events.post ~  jucon.1lag + legcon.1lag + altinf.1lag + libdem.1lag + gdpgro.1lag +  + osorg.1lag  + natlpartyorg.lag +   inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election  + regional_success_lag, data = nelda2.sub)
summary(test3)

ggplot(mapping = aes(x=predict(test3, type = "response"), y= test3$model$n.events.post)) + geom_point() + coord_cartesian(xlim=c(0, 500))

newdata <- modelr::add_predictions(nelda2.sub, test3)
newdata <- newdata %>% mutate(pred_error = n.events.post - pred)
  #because this is set up so that the predicted value is subtracted from the actual, underpredicting
  # protest is a positrive value (i.e. actual 5 - 0 predicted = 5)

test4 <- lm(pred_error ~ winner.share.upd + v2elirreg.inv + presidential, data = newdata)
summary(test4)

test5 <- lm(pred_error ~ winner.share.upd*v2elirreg.inv + presidential, data = newdata)
summary(test5)

sjPlot::plot_model(test5, type = "pred", terms = c("v2elirreg.inv", "winner.share.upd [.4, .7]"))

plot(newdata$v2elirreg.inv, newdata$pred_error)
```

Predicting the level of election manipulation, and then seeing if actual values above prediction are associated with protest

```{r}
nelda2.sub <- nelda2.sub %>% mutate(inc.confident.num = ifelse(inc.confident == "N/A", NA, ifelse(inc.confident == "yes", 1, 0)))

###For testing missingness
subsample <- nelda2.sub %>% dplyr::select(v2elirreg.inv, jucon.1lag, legcon.1lag, gdpgro.1lag,  natlpartyorg.lag,  presidential, urban.pct, rentierstate,  taxstate,  unscheduled_election, regional_success_lag, physinteg.1lag, antisys.1lag, csenv.1lag, preelection_concerns, inc.termlimit.num, liberal_no_jucon, v2elirreg.inv.lag, patronage.appts.1lag,
                                                  state.owned.1lag)
summary(subsample)
############################ Note: Drop legcon from analysis because of high missingness and high cor with lib_no_jucon

test6 <- lmer(v2elirreg.inv ~ jucon.1lag +  gdpgro.1lag +  natlpartyorg.lag   +  presidential +  urban.pct + rentierstate + taxstate +  unscheduled_election + regional_success_lag + physinteg.1lag + antisys.1lag + csenv.1lag + preelection_concerns + inc.termlimit.num   + liberal_no_jucon + v2elirreg.inv.lag +
                patronage.appts.1lag +  state.owned.1lag +  v2elembaut + (1 | stateid), data = nelda2.sub) 
summary(test6)


testdata <- broom.mixed::augment(test6)
  #This adds fitted values and residuals.
  #Residuals are actual values minus predicted value, so
  #over-predicting fraud will result in a negative number (actual fraud < predicted )
  #Under-predicting fraud--what we are interested in--will result in a positive number (actual > predicted)

## Need to add rownames to nelda2.sub, so that can merge variables from nelda2.sub into testdata
nelda2.sub <- nelda2.sub %>% mutate(.rownames = rownames(nelda2.sub))
neldavars <- nelda2.sub %>% dplyr::select(.rownames, n.events.post, inc.lose, winner.share.upd, country, year, diem_explicheat_max, diem_fraud_max, country_id_year, surv_status,  inc.replaced.prot, d.events.num,
                                          legcon.1lag, osorg.1lag, altinf.1lag, libdem.1lag,  winner.share.upd, n.events.pre)
testdata <- testdata %>% left_join(neldavars, by = ".rownames")

model_protest <- glmmTMB(n.events.post ~  jucon.1lag + legcon.1lag + osorg.1lag + altinf.1lag + libdem.1lag  + natlpartyorg.lag +  gdpgro.1lag  +   winner.share.upd + .resid  + presidential + inc.termlimit.num  +  physinteg.1lag  + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election + regional_success_lag + .resid*winner.share.upd,
                               ziformula=~.,
                              data = testdata %>% filter(inc.lose == 0),
                                family=truncated_nbinom2)
summary(model_protest)

model_protest2 <- glmmTMB(n.events.post ~  jucon.1lag + legcon.1lag + osorg.1lag + altinf.1lag + libdem.1lag  + natlpartyorg.lag +  gdpgro.1lag  +   winner.share.upd + .resid  + presidential + inc.termlimit.num  +  physinteg.1lag  + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election + regional_success_lag,
                               ziformula=~.,
                              data = testdata %>% filter(inc.lose == 0),
                                family=truncated_nbinom2)
summary(model_protest2)


plot(testdata$winner.share.upd, testdata$.resid)




testdata <- testdata %>% mutate(no_protest = ifelse(n.events.post == 0, 1, 0))
testdata <- as.data.frame(testdata)
model_protest_binary <- glm(no_protest ~ .resid*winner.share.upd, family = binomial(link = "logit"),
                             data = testdata %>% filter(inc.lose == 0))
plot_binary_margin_typ_n <- sjPlot::plot_model(model_protest_binary, type = "pred", terms = c(".resid", "winner.share.upd [.2, .8]"))
plot_binary_margin_typ_n <- plot_binary_margin_typ_n +  labs(x = "Excess election fraud", y = "Predicted probability", title = "Predicted probability of no protest", color = "Incumbent vote-share") + theme_bw()



model_protest2_binary <- glm(no_protest ~ .resid + winner.share.upd, family = binomial(link = "logit"),
                             data = testdata %>% filter(inc.lose == 0))



sjPlot::plot_model(model_protest2_binary, type = "pred", terms = c(".resid", "winner.share.upd [.2, .8]"), show.data = T)
sjPlot::plot_model(model_protest2_binary, type = "est", vline.color = "black") + theme_bw()


### Seeing how residuals compare to DIEM data

summary(lm(.resid ~ diem_explicheat_max + diem_fraud_max, data = testdata))
plot(testdata$diem_explicheat_max, testdata$.resid)
plot(testdata$diem_fraud_max, testdata$.resid)
  ##This shows that the resids are basically noise with regard to election observer reports, which should be good; I think this helps push back against the idea that V-Dem coders are giving higher scores to protest elections. But it would be good to push deeper and look at the correlation only among the most up-coded resids.

high_resids <- testdata %>% filter(.resid >= .222)
summary(lm(.resid ~ diem_explicheat_max + diem_fraud_max, data = high_resids))

ggplot(data = testdata, aes(x = jitter(diem_fraud_max), y = .resid)) + geom_point(aes(size = n.events.post))

plot(high_resids$diem_explicheat_max, high_resids$.resid)
plot(high_resids$diem_fraud_max, high_resids$.resid)
  #We do see more outliers here, good to think deeper--there are two major outliers that are also big protest events


### Duration

cox1_b <- coxph(Surv(d.events.num, surv_status) ~ winner.share.upd  + .resid, data = testdata %>% filter(inc.lose == "0" & n.events.post > 0 & inc.replaced.prot == 0))
summary(cox1_b)


## DIEM and protest

model_protest_diem <- glmmTMB(n.events.post ~   winner.share.upd +  diem_explicheat_max ,
                               ziformula=~.,
                              data = nelda2.sub %>% filter(inc.lose == 0),
                                family=truncated_nbinom2)
summary(model_protest_diem)

```


```{r}
mydf <- ggpredict(model_protest2, type = "count", terms = ".resid [all]", back.transform = T)
ggplot(mydf, aes(x, predicted)) +
  geom_line() +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .1) + coord_cartesian(ylim = c(0, 100))


library(pscl)
model_protest2b <- zeroinfl(n.events.post ~  .resid + winner.share.upd | ., data = testdata %>% dplyr::select(n.events.post, .resid, winner.share.upd), dist = "negbin")
summary(model_protest2b)

newdata1 <- expand.grid((seq(from = -1.2, to = 1.3, by = .1)), mean(testdata$winner.share.upd, na.rm=T))
colnames(newdata1) <- c(".resid", "winner.share.upd")
newdata1$phat <- predict(model_protest2b, newdata1)

ggplot(newdata1, aes(x = .resid, y = phat)) +
  geom_point() +
  geom_line() +
   labs(x = "Fraud relative to baseline", y = "Predicted protest events")





model_protest2c <- zeroinfl(n.events.post ~  .resid*winner.share.upd + .resid + winner.share.upd  | ., data = testdata %>% dplyr::select(n.events.post, .resid, winner.share.upd), dist = "negbin")
summary(model_protest2c)


newdata2 <- expand.grid((seq(from = -1.2, to = 1.3, by = .1)), seq(from = 0, to = 1, by =.25))
colnames(newdata1) <- c(".resid", "winner.share.upd")
newdata1$phat <- predict(model_protest2c, newdata1)

ggplot(newdata2, aes(x = .resid, y = phat, colour = factor(winner.share.upd))) +
  geom_point() +
  geom_line() +
   labs(x = "Fraud relative to baseline", y = "Predicted protest events")






cox1 <- coxph(Surv(d.events.num, surv_status) ~ jucon.1lag + legcon.1lag + altinf.1lag + libdem.1lag +  osorg.1lag + gdpgro.1lag + natlpartyorg.lag + winner.share.upd  + presidential + inc.termlimit.num  +  physinteg.1lag + physintlag.sq + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election + regional_success_lag + v2elirreg.inv , data = nelda2.sub %>% filter(inc.lose == "0" & n.events.post > 0 & inc.replaced.prot == 0))
summary(cox1)


```


```{r}
nelda2.sub <- nelda2.sub %>% group_by(country) %>% mutate(elirreg_mean = mean(v2elirreg.inv, na.rm=T))
nelda2.sub <- nelda2.sub %>% mutate(elirreg_mean_diff = v2elirreg.inv - elirreg_mean)


model_protest1 <- glmmTMB(n.events.post ~  jucon.1lag + legcon.1lag + osorg.1lag + altinf.1lag + libdem.1lag  + natlpartyorg.lag +  gdpgro.1lag  +   winner.share.upd*elirreg_mean_diff  + presidential + inc.termlimit.num  +  physinteg.1lag  + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election + regional_success_lag,
                               ziformula=~.,
                              data =nelda2.sub %>% filter(inc.lose == 0),
                                family=truncated_nbinom2)
summary(model_protest1)
sjPlot::plot_model(model_protest1, type ="pred", terms = c("elirreg_mean_diff" , "winner.share.upd [.2, .8]")) + coord_cartesian(ylim = c(0, 50))



nelda2.sub <- nelda2.sub %>% mutate(no_protest = ifelse(n.events.post == 0, 1, 0))
model_protest_binary <- glm(no_protest ~  jucon.1lag + legcon.1lag + osorg.1lag + altinf.1lag + libdem.1lag  + natlpartyorg.lag +  gdpgro.1lag  +   winner.share.upd*elirreg_mean_diff  + presidential + inc.termlimit.num  +  physinteg.1lag  + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election + regional_success_lag,
                             data =nelda2.sub %>% filter(inc.lose == 0),
                                family=binomial(link = "logit"))
summary(model_protest_binary)
sjPlot::plot_model(model_protest_binary, type="pred", terms = c("elirreg_mean_diff" , "winner.share.upd [.2, .8]"))




model_protest2 <- glmmTMB(n.events.post ~  jucon.1lag + legcon.1lag + osorg.1lag + altinf.1lag + libdem.1lag  + natlpartyorg.lag +  gdpgro.1lag  +   winner.share.upd + elirreg_mean_diff  + presidential + inc.termlimit.num  +  physinteg.1lag  + urban.pct + rentierstate + taxstate + n.events.pre + unscheduled_election + regional_success_lag,
                               ziformula=~.,
                              data =nelda2.sub %>% filter(inc.lose == 0),
                                family=truncated_nbinom2)
summary(model_protest2)

```


```{r}
#Lots of missinginess in winner share

winner_missing <- nelda2.sub %>% filter(is.na(winner.share.upd) == T) %>% dplyr::select(country, year)
```

What I'm looking for here is weak government -> high fraud + narrow vote share -> protest. Not sure if that pattern reveals itself.
```{r}
ggplot(nelda2.sub %>% filter(presidential == 1), aes(x = winner.share.upd, y = v2elirreg.inv)) + geom_point(aes(size=n.events.post)) + geom_vline(xintercept = .5, linetype = 2) + geom_hline(yintercept = 0)
```

\newpage
# References
